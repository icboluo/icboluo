缓存：避免数据库访问速度过慢，在数据库上增加了缓存层

## 综述

增加中间缓存，造成了一份数据变成多份的情况，需要考虑一致性问题

缓存如果并发：需要考虑尤其是写缓存时候的并发情况，对数据延时情况进行分析

可用性，增加缓存，缓存服务宕机，会影响本服务，其可用性降低

内存过期：无效的缓存需要清理，做淘汰机制

## 为什么要使用缓存

    高性能：对于热点数据，把热点数据放到缓存中，用户访问的时候直接去缓存中取，直接操作内存效率高
    高并发：mysql qps 1万（4核8g）,单机redis可以达到10万+，集群更高；把数据库中的部分数据放到
        缓存中，请求不经过数据库，可以提高并发量
    QPS（Query Per Second）：服务器每秒可以执行的查询次数

## 带来的问题：

    复杂度增加：缓存和数据库的一致性、热点缓存等等
    开发成本增加：需要增加缓存服务、需要耗费内存

## 缓存应该包含：

    过期时间、淘汰机制、命中率统计等

## 本地缓存：

    jdk自带 hashmap concurrentHashMap 没有过期时间功能
    Ehcache：比较重量，提供嵌入mybatis hibernate作为多级缓存、持久化、集群功能
    Guava Cache：和Spring Cache差不多
    Spring Cache：代码简洁、容易出现缓存穿透，内存溢出
    Caffeine：比Guava Cache各方面性能更加优秀，建议用这个替换

## 本地缓存对应的问题：

    本地缓存的优点：低依赖、比较轻量、比较简单相比于分布式缓存
    多个相同服务搭建集群（同一个服务部署到不同的服务器上），各个服务之间的缓存无法共享，
        因为本地缓存只有当前机器上有
    本地缓存的容量受部署的服务器现在明显：服务耗费内存多了，本地缓存的容量就会变少

## 分布式缓存的引入：

    分布式缓存主要解决了单机缓存容量受限制并且无法保存通用的信息
    的分布式缓存的性能、容量和提供的功能会更加强大
    分布式缓存缺点：需要引入额外的缓存服务、要保证缓存服务的高可用

## 缓存读写模式/更新策略：

### Cache Aside Pattern（旁路缓存模式）:

    write：更新db，删除cache
    read：从cache读数据，读取到返回，读取不到从db读数据放到cache再返回（读取不到就直接返回null）
    适用场景：read比较多的场景
    特点：同时维系db和cache，以db为主
    问题：首次请求一定不在cache中，热点数据可以提前放到缓存中

### Read/Write Through Pattern（读写穿透）

    write：查cache，cache中不存在，update db；cache中存在，更新cache，cache服务自己更新db
    read：查cache，cache中读取到，返回；读取不到，从db加载，写到cache，cache返回
    特点：read的时候，上面的是客户端写入cache中，这个是cache服务自己写进cache中的；
        write的时候，也是有cache服务负责cache对db的读写
    问题：和上面的一样

### Write Behind Pattern（异步缓存写入）

    特点：和上面的差不多，由cache服务负责cache读写，但是上面的是同步方式写入db，这个
        是异步方式批量写入db，写的性能非常高
    适用场景：适用于一些数据经常变化的业务场景，比如点赞数、阅读数量
    问题：对db和cache的一致性有考验，如果cache数据未同步到db，然后cache服务宕机就gg

## 数据结构

redisList不适合记录需要修改的数据（客户，如果客户的名称需要修改，redisList很难根据code获取产品线数据，然后去修改）;
如果要记录有列表中需要修改的数据，并没有直接的数据结构；nosql无法进行条件查询，（没办法进行where）如果要进行条件查询只能全部查出来放入到内存中;
针对于这种update语句，一般情况下我们期望实现一种根据id update的功能，所以我们可以设置这样的数据结构 key:id:map

### list

    双向链表 
    应用场景: 发布与订阅或者说消息队列、慢查询
    list实现队列：头部放进去，尾部取出来
    list实现栈：头部放进去，头部取出来
    list可以查看长度，可以分页

### hash

    hash 是一个 string 类型的 field 和 value 的映射表，特别适合用于存储对象
    是数组+链表
    应用场景: 系统中对象数据的存储

### set

    类似于hashset
    可以基于 set 轻易实现交集、并集、差集的操作
    应用场景: 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景
    你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、
        共同粉丝、共同喜好等功能。这个过程也就是求交集的过程

### sorted set

    和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列
    应用场景： 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，
        各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息

## redis单线程-多线程

## redis给缓存数据设置过期时间

    可以设置过期时间，可以查看过期时间
    作用：防止内存溢出、部分业务场景，比如验证码1分钟内有效、用户登录的token一天之内有效

### redis如何判断是否过期

    redis通过一个过期字典，保存过期时间，可以看做一个hash表，hash表的键是指向redis数据库中
        的键，过期字典的值保存redis数据库键的过期时间，是一个long long类型的整数

### redis过期数据的删除策略

常用的过期数据删除策略：

#### 惰性删除

只会在取出key的时候才对数据进行过期检查。这样对CPU最友好，但是可能会造成太多过期 key 没有被删除

#### 定期删除

每隔一段时间抽取一批 key 执行删除过期key操作。并且，Redis 底层会并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响，对内存更加友好

redis采用的是 定期删除+惰性/懒汉式删除（先抽取一批删，在访问的时候再看看是否过期，过期了删）

问题：这两种方式都是随机删除，还是删不干净，需要引入

### redis内存淘汰机制

volatile-lru（least recently used）不稳定的（这里的意思是过期的） 最少的 最近的 使用

    从已设置过期时间的数据集中挑选最近最少使用的数据淘汰（这个是最近的）

volatile-ttl：

    从已设置过期时间的数据集中挑选将要过期的数据淘汰

volatile-random：

    从已设置过期时间的数据集中任意选择数据淘汰

allkeys-lru（least recently used）：

    当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）

allkeys-random：

    从数据集中任意选择数据淘汰

no-eviction：驱逐

    禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错

volatile-lfu（least frequently used）：频繁的

    从已设置过期时间的数据集中挑选最不经常使用的数据淘汰（这个是总的）

allkeys-lfu（least frequently used）：

    当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key

## redis持久化机制

### 快照（snapshotting）持久化（RDB）

    是redis默认的持久化方式，可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本，
    redis创建快照后，可以对快照进行备份，可以将快照复制到其他服务器，创建具有相同数据的服务器副本，
    （这时我们可以用redis主从结构，提高redis性能）；也可以将快照保留到原地，以便重启服务器的时候使用
    save 900 1    在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
    save 300 10   在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
    save 60 10000 在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

### AOF（append-only file）持久化 （附加

    redis配置文件中3种不同的持久化方式
    appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
    appendfsync everysec  #每秒钟同步一次，redis性能基本没有什么影响，显示地将多个写命令同步到硬盘
    appendfsync no        #让操作系统决定何时进行同步

### 混合持久化

TODO

## redis事务

TODO

## 缓存穿透

大量请求的key不在缓存中，请求直接到数据库是上；比如黑客制造大量key去访问

解决办法：

参数校验：id不能小于0，邮箱格式等等校验

缓存无效的key，并设置过期时间：必须设置过期时间（否则会缓存会存储大量key，容易被攻击）；如果key变化频繁，不能从根本上解决问题

布隆过滤器：把所有可能出现的key值放到布隆过滤器中，请求进来，先进行布隆过滤器再经过cache和db

缺点 ：小概率会误判，判断是否存在是用hash，不同的字符串hash值可能相等

## 缓存雪崩

缓存在同一时间大面积失效，后面的请求都直接落到数据库上，造成数据库短时间内承受大量请求

出现场景： cache服务宕机，所有请求都到数据库上； 一些热点数据，在某一时刻大量失效，比如秒杀系统没有进行热点缓存

解决方案： 采用redis集群，避免单机服务器出现问题，整个缓存服务不可用；限流，避免处理大量请求 设置不同的失效时间，比如随机时间；设置热点缓存永不失效

## 缓存和数据库数据的一致性

对于 旁路缓存模式：write 写入db成功，删除cache失败

缩短缓存失效时间，这样缓存容易失效就回去db去加载；治标不治本，对于先删cache再写db不适合

增加cache更新重试机制，如果cache服务不可用，就隔一段时间再试一次；如果多次重试均失败，可以把更新失败的key存到队列中，

等cache服务可用的时候，再将缓存中对应的key删除    
