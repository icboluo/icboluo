## 进程和线程

#### 进程

进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的

系统运行一个程序即是一个进程从创建、运行到消亡的过程

java中，启动main函数就是启动了一个JVM进程，而main函数所在的线程就是这个进程中的一个线程，也称主线程

#### 线程

线程是比进程更小的执行单元，一个进程在执行过程中可以产生多个线程

同类的多个线程共享进程的堆和方法区的资源

每个线程有自己的**程序计数器、虚拟机栈和本地方法栈**

系统在产生一个线程，或是在各个线程之间作切换，负担要比进程小很多，所以，线程也是轻量级进程

#### 关系

多个线程共享进程的堆和方法区（元空间 资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈

基本上各进程是独立的，而各线程则不一定，同一进程中的线程极有可能会相互影响

线程执行开销小，但不利于资源的管理和保护，而进程正相反

#### 程序计数器

* 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理
* 多线程情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换会俩的时候能够知道该线程上次运行位置

> 如果执行的是native方法，那么程序计数器记录的是undefined地址；只有执行的是java代码时程序计数器记录的才是下一条指令的地址

程序计数器私有的主要目的是为了线程切换后能恢复到正确的执行位置

#### 虚拟机栈和本地方法栈

虚拟机栈：每个java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息\
从方法调用直至执行完成的过程，就对应着一个栈帧在java虚拟机栈中入栈和出栈的过程

本地方法栈：虚拟机栈为虚拟机执行java方法（也就是字节码 服务，而本地方法栈则为虚拟机使用到native方法服务\
在HotSpot虚拟机中和java虚拟机栈合二为一

私有保证线程中局部变量不被别的线程访问到

堆和方法区是所有线程共享的资源，其中堆比较大（主要存放新建的对象（几乎所有的对象都在这里分配内存\
方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

## 并发与并行

并发：多个以上的作业在同一**时间段**内执行

## 多线程

多线程可以提高系统的并发能力以及性能

相对于进程：线程更加轻量，是程序执行的最小单位；线程间的切换和调度的成本远远小于进程\
多核cpu意味着多个线程可以同时运行，减少了线程上下文切换的开销

单核情况下：使用多线程主要是为了提高单进程利用cpu和IO系统的效率
    
    假设只运行一个java进程，一个线程，请求IO的时候，此线程被IO阻塞，则整个进程被阻塞。cpu和IO设备永远只有一个
    在运行；这时，简单认为系统的效率为50%；当使用多线程的时候，一个线程被IO阻塞，其他线程还可以使用cpu...,可以
    提高了java进程利用系统资源的整体效率

多核情况下：多线程主要是为了提高进程利用多核cpu的能力；一个进程一个线程的情况下，无论系统有几个cpu核心，都只会
有一个cpu核心被利用到；创建多线程，这些线程可以被映射到底层多个cpu上执行，在任务中多个线程没有资源竞争的情况下，
任务执行的效率会有显著的提高，=单核时间数/cpu核心数

并发线程并不总是能提高程序运行速度，而且并发线程会遇到：内存泄漏、死锁、线程不安全...

## 线程状态

1.new 新建，线程被创建，但是还没有调用start方法\
2.runnable 运行（java没有就绪状态，把就绪和运行一起称为运行\
3.blocked 阻塞，表示线程阻塞于锁\
4.waiting 等待，进入该状态表示当前线程需要等待其他线程做出一些 通知|中断 动作\
5.timed_waiting 有时间的等待，可以自己通知自己，指定时间自行返回\
6.terminated 终止，表示当前线程一级执行完毕

```java
public class MyThread {
    /**
     * @see Thread.State
     */
    private void state() {

    }
}
```

在操作系统层面有ready和running状态，而在JVM层面只能看到runnable状态

调用start方法后开始运行，线程这时候处理ready状态；可运行状态的线程获得了cpu时间片（timeslice 后就处于running状态




