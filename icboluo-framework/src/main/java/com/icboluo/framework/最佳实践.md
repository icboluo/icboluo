## 状态模式用于业务流程处理

当一个主业务有不同的业务流程/不同的当前处理人逻辑：
> 将当前处理人单独出来到一个表中，更好使用

```sql
create table best_practice_cur_handler
(
    id             bigint auto_increment comment 'id'
        primary key,
    cur_handler    varchar(32)       not null comment '当前处理人',
    role           tinyint           not null comment '角色',
    is_take_effect tinyint default 1 not null comment '是否生效',
    main_id        bigint            null comment '主表id'
)
    comment '最佳实践-当前处理人';
```

## 对于web层开放的接口

对于流程数据来说，将实体参数分散开来比较合适，这样的好处有：

* 更容易生成接口文档，对外接口更加简单
* 对于后端来说更清晰，不会出现一个接口混乱的情况，业务清晰
* 校验更加简单，可以统一处理校验器

## 日志

* 对于问题点，需要注意error级别的日志，尤其是单行error日志

* 出现异常之后，异常点在哪里就调试哪里，比如 easy excel 报json array not convert，就应该提供json array 的支持， 而不是对list类型的字段提供list
  convert支持，这同样要求系统报错打印error级别的日志尤其重要

## web

对于有的返回值不会转换成json格式，可以看2点

* content/type 是不是json
* 返回的是不是json对象

## 业务

* 对于状态字段，从业务数据里面提取所有的状态有些不合理，应该从配置表中获取

## git

git soft 是文件变为之前的待提交状态

## 命名

info 不适合作为命名字段，太过概况性质，创建的时候简单，使用的时候辨别度比较低

## mdc

mdc使用的是 thread local，可以当做thread local使用，异步线程之间通信可以使用mdc和thread local，mdc支持日志的追踪定位等功能

## idea 快捷键

* ctrl shift f 全局搜索
* ctrl shift r 全局替换
* fn键 解除锁定

## map

map中可以存放函数式接口，做转换使用

## sql

测试代码不要与sql层混起来，会使测试难度上升

* not in 没有使用索引
* not exist 使用到了索引

## 接口

接口用collection接受似乎比用list set接受好一点，方便传参，单是也会多一层处理

对于大部分处理list数据的接口，为了满足单一原则（充分），需要增加对obj类型的支持

## 异常

业务异常情况的处理，可以从2个角度阐述：

* 抛出异常，扩大异常，使异常在开发阶段更加容易暴露出来
* 隐藏异常，对异常进行额外处理，可以对各种数据做兼容性支持，不容易报错，但是错误数据流转，会造成回溯异常困难

## 代码宽度

代码尽量不要超过竖线过多，这样会在下面出现滚动条，不能直接看完所有代码，造成阅读障碍，120个字符即可

## map

map是可以放stream表达式的，可以使一些处理变得简单，比如做计算器的表达式存放/做对象的get函数映射

## 算法

算法不要使用静态变量存储值，因为静态变量是全局变量，可能有数据串起来的问题

算法中存储多次访问的值用数组比较合适，单次访问的使用使用常量

## 日志

日志全量记录和只记录更新内容有下面的不同

* 全量记录会记录所有的内容，数据比较齐全，不用链式搜索日志数据/回溯简单
* 更新记录只记录部分数据，不会造成数据量过大，但是查找部分数据会需要找上一个日志的记录，比较繁琐/数据量比较少

## 返回值

返回值不是json对象的时候，看一下是不是 application/json， 然后再看一下json格式是否有问题，如果Integer作为json的 k值，不是合法json，会报错，这种情况下不一定是序列化问题

## mybatis

mybatis 更改公共内容比如insert的时候需要增加注释，这些公共内容替换的时候要merge，不能直接替换，insert增加了注释，才能 知道返回了id

## stream

all match 如果流为空返回true，any match则返回false

分区如果用null值，继续后序操作，会npe（分区null情况需要重点关注

## builder

lombok的builder注解使用的时候，会使用调构造方法，不能生成无参构造，需要额外增加注解

## post handler

post handler 在controller报异常的时候不会执行，需要用after handler

## mysql

mysql left join 语句需要增加索引提高执行效率

left join 右表的条件列上要加上索引

插入数据库的数据，不需要完整的展示出来

where条件中多过滤一些行，使驱动表小一点

数据库设计的三大范式

1.原子性

2.自己做自己的事情

3.不要搞别人的东西；物体加一个id就行，再加name不是搞事情，再加一连串数据，太难维护了

## pom版本号

单个版本号有利于各个环境统一代码统一跑 区间版本号有利于依赖更新到最新

## controller

controller 请求方法如果使用private修饰，会导致注入的其他类为null，注意..

## .gitignore

该文件会把文件里面标注的东西不交给git管理

## todo

todo应该标明事由，方便处理

## 调接口

调用第三方接口的时候，需要增加日志记录，必要时，可以try catch，error信息可以入库

## init

init异步处理的时候的缺点

单个接口调用时间难以统计，难以确定那个接口耗时多，难以优化

debug调试困难，一跳过断点就好多接口通过，打印好多日志

代码复杂度上升，本地线程的数据需要同步到异步线程才能使用

## 状态值

带有状态值的情况下，单据的新增修改处理需要首先判断状态值，防止页面打开多个，多次调用对数据库造成影响

对参数要进行合法性校验

## mybatis plus

mybatis plus 实体类名不能更改，是一个坑

insert的时候默认不会携带主键，在Entity中配置为 Input即可

## 函数式接口

善于使用函数式接口对公共代码进行抽取，对模板进行整理

fun使用的时候先get、apply，禁止循环调用

## es

sku种类不多的时候，可以直接使用spu管理生成多个spu，针对的是小数据量

## redis todo

redis 布隆过滤器

## thread local

thread local相当于一个线程的一个全局变量

thread local不是解决对象共享访问问题的，主要是提供了保持对象的方法和 避免参数传递 的方便的对象访问方式

thread local和@async 前面的代表本地线程，后面代表异步线程，数据不能共享，可以用线程池、代理增强等方式处理

## async

async必须交给spring，不能自己new

自己类调用自己是没有效果的

then apply 前后是同一个线程执行（。。。

async同类调用没有效果：用的是aop，aop用的是动态代理；动态代理针对的是方法级别，方法内部调用本类的方法，是不会使用到代理类的

## 枚举

枚举的match方法静止写成静态方法，会造成调用麻烦

## sort

java用多个条件排序可以使用权重，是目前为止最好的方式

## request

http request selelvet 可以注入，也可以在controller方法内获取，向后传参，如果下层需要使用，注入好一点

## 排序

在进行复杂比较排序的时候，可以使用权重，这个是目前为止最好的方式

比较器中有then函数，可以代替多级比较器

## sku

大数据量业务直接关联sku，事实上，spu只是产品总和，不用于业务数据的流转、

## 状态模式

状态模式中，after的数据来源应该是copy之后的

## 哈希算法

比较大的二进制数据转换为长度较短的数据的映射函数；可以看做是一个单向函数，不可逆，用作加密，也可以用作查找

## 函数式接口

函数式接口可以对多返回值函数进行封装去消费

分区如果使用null值，继续后序操作，会npe

Stream过程中，对象数据是被共享的

## 开发流程

uat环境发布后，禁止大面积修改代码，问题回归后，没有保险不能随便修改

版本迭代过程中，前期多修改代码，后期少修改代码

## web

java 中http的session用对象 HttpSession来表示

## 程序计数器

生命周期和线程一样

## 第三方

第三方数据要认为不可信，比如上游把客户删掉，本地如果存储，会产生一些难以预料的问题，需要的不可信的数据进行统计

## 函数

函数要写的单一，使角色失效，不要写成使当前处理人失效（现在虽然当前处理人和角色处理逻辑是一致的， 但是如果失效的角色不绑定当前处理人，函数就会出现问题

## idea

单击服务名跳转到启动类中，需要右键下边工具栏边界调整即可

## 系统优化方向

1.最长耗时

降低效果最明显，例如优化sql，多线程编程

2.最多使用

整体效果最好，例如鉴权、系统类公告

## 多线程

每一个请求都会使用一个线程，tomcat会维护一个线程池，每个http请求会在tomcat中取一个空闲的线程

多线程中有任务调度的时间，单核cpu的效率是下降的，内核级别的多线程（多核cpu）效率会提升

## 执行顺序

代码块是在实例化的时候运行的，实例化时代码块运行完才能够运行构造器（实例化阶段，先执行代码块，再执行构造方法

## lombok

lombok是编译期生效的注解

## mq

优点：

解耦：生产者不需要关注消息被谁消费

异步：我们认为消息的处理是一个耗时操作，用异步存放消息可以减少响应所需要的时间

削峰：将英雄db的数据放到消息队列中消费，避免一个时间点大量数据到数据库

缺点：

系统可用性降低：加入mq，需要考虑消息丢失、mq挂掉的情况

系统复杂度提高：需要考虑重复消费、处理消息丢失、消息传递顺序

一致性问题：异步处理会提高系统响应速度，但也会出现消息没有被正确消费的问题

## 关键字

@IntrinsicCandidate ：源码随便写的，执行的时候有一套高效的执行方案

native 就像是default方法一样，执行的时候会调c或者操作系统的指令


