## 状态模式用于业务流程处理

当一个主业务有不同的业务流程/不同的当前处理人逻辑：
> 将当前处理人单独出来到一个表中，更好使用

```mysql
create table best_practice_cur_handler
(
    id             bigint auto_increment comment 'id'
        primary key,
    cur_handler    varchar(32)       not null comment '当前处理人',
    role           tinyint           not null comment '角色',
    is_take_effect tinyint default 1 not null comment '是否生效',
    main_id        bigint            null comment '主表id'
)
    comment '最佳实践-当前处理人';
```

## 对于web层开放的接口

对于流程数据来说，将实体参数分散开来比较合适，这样的好处有：

* 更容易生成接口文档，对外接口更加简单
* 对于后端来说更清晰，不会出现一个接口混乱的情况，业务清晰
* 校验更加简单，可以统一处理校验器

## web

对于有的返回值不会转换成json格式，可以看2点

* content/type 是不是json
* 返回的是不是json对象

java 中http的session用对象 HttpSession来表示

## 业务

* 对于状态字段，从业务数据里面提取所有的状态有些不合理，应该从配置表中获取

## git

git soft 是文件变为之前的待提交状态

git远端回滚提交记录

    1.reset返回到这次提交时候的代码，再强制提交
    2.revert将选中的git记录作为要回滚的记录，然后再次commit回滚，再强制提交

#### .gitignore

    不要在idea中隐藏这个文件，往里面动态的添加不需要交给 git管理的东西，gitignore也必须提交
    该文件会把文件里面标注的东西不交给git管理
    .gitignore 项目均需要此文件，避免多于文件上传到远端分支，是一个很好的实践

10054

git config http.sslVerify "false"

git config --global http.sslVerify "false"

443

git config --global --unset http.proxy

git config --global --unset https.proxy

## 命名

info 不适合作为命名字段，太过概况性质，创建的时候简单，使用的时候辨别度比较低

## map

map中可以存放函数式接口，做转换使用

map是可以放stream表达式的，可以使一些处理变得简单，比如做计算器的表达式存放/做对象的get函数映射

## 测试代码不要与sql层混起来，会使测试难度上升

## 接口

接口用collection接受似乎比用list set接受好一点，方便传参，但是也会多一层处理

对于大部分处理list数据的接口，为了满足单一原则（充分），需要增加对obj类型的支持

接口上加注解好像都没有什么用

## 异常

业务异常情况的处理，可以从2个角度阐述：

* 抛出异常，扩大异常，使异常在开发阶段更加容易暴露出来
* 隐藏异常，对异常进行额外处理，可以对各种数据做兼容性支持，不容易报错，但是错误数据流转，会造成回溯异常困难

## 代码宽度

代码尽量不要超过竖线过多，这样会在下面出现滚动条，不能直接看完所有代码，造成阅读障碍，120个字符即可

## 算法

算法不要使用静态变量存储值，因为静态变量是全局变量，可能有数据串起来的问题

算法中存储多次访问的值用数组比较合适，单次访问的使用使用常量

## 返回值

返回值不是json对象的时候， 看一下是不是 application/json， 然后再看一下json格式是否有问题， 如果Integer作为json的 k值，不是合法json，会报错，这种情况下不一定是序列化问题

## stream

all match 如果流为空返回true，any match则返回false

分区如果用null值，继续后序操作，会npe（分区null情况需要重点关注

## pom版本号

单个版本号有利于各个环境统一代码统一跑 区间版本号有利于依赖更新到最新

## Controller

controller 请求方法如果使用private修饰，会导致注入的其他类为null，注意..

## TODO

TODO应该标明事由，方便处理

## 调接口

调用第三方接口的时候，需要增加日志记录，必要时，可以try catch，error信息可以入库

## init

init异步处理的时候的缺点

单个接口调用时间难以统计，难以确定那个接口耗时多，难以优化

debug调试困难，一跳过断点就好多接口通过，打印好多日志

代码复杂度上升，本地线程的数据需要同步到异步线程才能使用

## 状态值

带有状态值的情况下，单据的新增修改处理需要首先判断状态值，防止页面打开多个，多次调用对数据库造成影响

对参数要进行合法性校验

## 函数式接口

    善于使用函数式接口对公共代码进行抽取，对模板进行整理
    fun使用的时候先get、apply，禁止循环调用
    函数式接口可以对多返回值函数进行封装去消费
    分区如果使用null值，继续后序操作，会npe
    Stream过程中，对象数据是被共享的
    当一个元素和容器元素进行匹配的时候，试着使用Stream，会很大程度上简写代码，而且阅读复杂度也比较低

## 枚举

枚举的match方法静止写成静态方法，会造成调用麻烦,需要修改为成员方法

## HttpServletRequest

HttpServletRequest 可以注入，也可以在Controller方法内获取，向后传参，如果下层需要使用，注入好一点

```java
import org.springframework.web.bind.annotation.GetMapping;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;

public class Http {
    // 注入获取
    @Resource
    private HttpServletRequest httpServletRequest;

    // Controller方法内获取，下层有需要，向后传参即可
    @GetMapping
    public void init(HttpServletRequest request) {

    }
}
```

## sort

在进行复杂比较排序的时候，可以使用权重，这个是目前为止最好的方式

比较器中有then函数，可以代替多级比较器

java用多个条件排序可以使用权重，是目前为止最好的方式

## 状态模式

状态模式中，after的数据来源应该是copy之后的

## 哈希算法

比较大的二进制数据转换为长度较短的数据的映射函数；可以看做是一个单向函数，不可逆，用作加密，也可以用作查找\
对象的hash值会随着对象的属性变化而变化

## 开发流程

uat环境发布后，禁止大面积修改代码，问题回归后，没有保险不能随便修改

版本迭代过程中，前期多修改代码，后期少修改代码

## 程序计数器

生命周期和线程一样

## 第三方

第三方数据要认为不可信，比如上游把客户删掉，本地如果存储，会产生一些难以预料的问题，需要的不可信的数据进行统计

## 函数

函数要写的单一，使角色失效，不要写成使当前处理人失效（现在虽然当前处理人和角色处理逻辑是一致的， 但是如果失效的角色不绑定当前处理人，函数就会出现问题

## 系统优化方向

1.最长耗时

降低效果最明显，例如优化sql，多线程编程

2.最多使用

整体效果最好，例如鉴权、系统类公告

## 执行顺序

代码块是在实例化的时候运行的，实例化时代码块运行完才能够运行构造器（实例化阶段，先执行代码块，再执行构造方法

## lombok

lombok是编译期生效的注解

引入log日志2个步骤： 1、在pom.xml中，引入slf4j的依赖 2、添加配置文件log4j.properties .bak使配置文件无效

lombok的builder注解使用的时候，会使用调构造方法，不能生成无参构造，需要额外增加注解

## 关键字

@IntrinsicCandidate ：源码随便写的，执行的时候有一套高效的执行方案

native 就像是default方法一样，执行的时候会调c或者操作系统的指令

## 保存

对于保存的数据和保存状态要进行严格的区分，可以增加draft来区别2种；

保存的数据如果是新建一张表，不需要增加saveStatus来标识来源于保存的数据

## 约束

链式调用不如分发式调用，从数据库找130，再从枚举中找到匹配的枚举（好像在枚举上直接标记130的数据更加简单，可以省略一个映射关系

把配置项写到java代码中稍显不足，每建一个表头，就要新建一个i18的枚举类与之对应，而且需要维护默认值、个人适配的值

## 重构

重构不应该做功能添加；添加功能尽量不要修改原有代码

小步重构出现的问题容易定位：重命名、移动位置

重构出了错误先考虑回头，不要继续往下走了

函数功能要单一，否则会发生函数参数过多等问题；小步优化，别怕

内联函数：将调用的子函数放到主函数中

一个大函数中，把查询函数和修改函数分开

减小变量的多次赋值；提炼类，内联类

## 产品生命周期

GA->EOM->EOP->EOFS->EOS

GA(general availability 一般可获得性) 发布、通用可获得性、产品上市时间

EOM(end of marketing 营销) 停止销售时间

EOP(end of production) 停止生产

EOFS(end of full support) 停止全面支持，对版本新发现的缺陷停止修复，不再提供新的补丁版本，已发现的缺陷将继续进行根因分析和修复

EOS(end of service and support) 停止服务时间

## 建模题：多叉树构建

对于构造函数，我们需要多增加一些映射、数组等关系构建，方便后面的查询处理；

一般意义上，不要太在乎复杂度，for循环慢慢写，不会出问题

## @value

@Value注解是不需要增加额外的依赖说明书写提示的，参考note服务pom注释

@ Optional标签代表依赖不会传递；

Environment是可以直接获取到配置文件中的内容的.properties

service.servlet.context-path可以设置项目ip地址统一前缀

fastjson需要放到序列化工具中的第一个，要不然都被别人执行了

拦截器需要添加到mvcconfigurater里面才行，不能实现一个接口空放着，直接加入bean容器中也不行，完全不需要加入bean容器中

数据库使用的是桥接模式

可以简单理解jvm为bin包、jre包含了bin+lib包、jdk包含jre+exe命令包

@Transient注解在接口上也是有效果的，而且作为父类，加上此注解，子类重写的方法也不会被序列化

完全二叉树的高度；好多算法中时间复杂度其实是log2 n，用log n来表示是不准确的，有一定的误导作用

求字符串的满足某种规则的切割方式：1.先求出所有满足规则的子串；2.对子串进行从前到后的索引拼接，查看是否拼接后的结果为完整字符串（可以采取拓扑排序的方式处理

StreamUtils.copy(inputStream,outputStream)是一个比较好用的api

经过测试，发现lombok nonnull注解放在接口上是没有作用的

response.setHeader("Content-Disposition","attachment;filename="+name+".xlsx");这个会造成中文乱码，需要先url编码后解码
response.setHeader("Content-Disposition","attachment;filename*=utf-8"+name+".xlsx");这个会造成中文乱码，需要先url编码后解码

spring-core 中的resource接口代表的是资源的抽象

InputStream is=Demo.class.getClassLoader().getResourceAsStream("Spring.xml");
Properties properties=new Properties();
properties.load(is)
可以加载配置文件，这个加载的相对路径前缀是classes 所以说，配置文件的加载使用类加载器更合适一点

一定要注意：lombok文件中必须小驼峰式，是所有的单词，包括callSuper，代码提示是错误的，不生效；位置倒显得没那么重要；value大小写均可

mybatis 的select all 函数是需要无参构造的

mysql的日期格式比较可以先把时间转换为日期 data() 再between

loback日志的路径记录相对路径是比较合适的，log； /log绝对路径不起作用 ../log也不行

鸡肋的对象，懒加载在部分情况下回失效；当懒加载的类被注入到其他类中的时候会失效；既然不能被注入，那要这个类也没有什么用了

base64是jdk提供的一个编码解码工具，编码后的字符串较长且最后显示为==

用例图（和类图差不多，主要说明了系统在干什么（而不是这么干

文档注释 段落标记需要使用前置p标签，不要使用自反标签（后置p标签







