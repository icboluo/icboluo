## sleep

Thread.sleep(0) 的作用：告诉cpu，我吃饱了，暂时不参与竞争\
在一个大的循环体中，放一个这个可以释放cpu资源，让其他的线程再进行竞争（界面不会出现卡死

# 锁

## 公平锁

多个线程按照申请顺序来获取锁

## 非公平锁

随便加进去

## 可重入锁

调用子函数不会死锁

## 多线程

每一个请求都会使用一个线程，tomcat会维护一个线程池，每个http请求会在tomcat中取一个空闲的线程

多线程中有任务调度的时间，单核cpu的效率是下降的，内核级别的多线程（多核cpu）效率会提升

## async

async必须交给spring，不能自己new

自己类调用自己是没有效果的

then apply 前后是同一个线程执行（。。。

async同类调用没有效果：用的是aop，aop用的是动态代理；动态代理针对的是方法级别，方法内部调用本类的方法，是不会使用到代理类的

## mdc

mdc使用的是 thread local，可以当做thread local使用，异步线程之间通信可以使用mdc和thread local，mdc支持日志的追踪定位等功能

## thread local

thread local相当于一个线程的一个全局变量

thread local不是解决对象共享访问问题的，主要是提供了保持对象的方法和 避免参数传递 的方便的对象访问方式

thread local和@async 前面的代表本地线程，后面代表异步线程，数据不能共享，可以用线程池、代理增强等方式处理

## sleep wait

sleep和wait均针对于锁，他们的不同和线程无关，均不会释放线程

## volition

防止指令重排

## 效率

异步追求效率的过程中，cf比join要好很多，cf能更小颗粒度的控制流程

## 异常排查

多线程内部问题调查，debug没有打印日志好用，相当于乱序debug，细节难以把握，应该泛泛的从日志分析，这样更加简单

记录死锁：

        多线程delete的时候死锁，原因是因为，多个线程同时del同一组数据
        调查吃力原因：只能从mysql中读取到那个表锁住了，不知道有多个操作同时操作这个表

        单个方法异常，其他线程回滚，但是本地线程也需要回滚，否则，事物会一直挂起，导致第二次以后的调用均会失败
        
        多线程操作同一张表，虽然一个删除是空删除，没有删除到同一行数据：查看死锁日志需要关注锁表
        具体场景如下：del a where b=; del a where c=; 其中任意一个有数据即可死锁；2个都没有不会死锁
        mysql一个navicat页面就是一次链接，也是一次会话，idea窗口同理，多次会话直接可以做事物测试

        可以搭配 explain 查看锁表情况，执行计划估算要读取的行数，读取的行数是1说明是行锁，读取的行数是多，说明是表锁，
        同样是删除操作，尽量让删除条件统一，这样不会锁表
        
        insert是表锁，因为要生成主键字段，索引等等，update是行级锁
        mysql的InnoDB存储支持行级锁，InnoDB的行锁是通过给索引项加锁实现的。这就意味着只有通过索引条件检索数据时，InnoDB才使用行锁，否则使用表锁
        InnoDB的行销是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁
## 线程池

线程池中的最大线程数触发时机：当核心线程满了之后，然后队列也满了，线程数量就会由核心线程数量变为最大线程数量

对于cf而言，队列容量为max，所以永远不会触发最大线程数量，除非同时也修改了队列容量

## 单例对象的多线程不安全

单例对象--共享对象；多线程---多个地方使用：多个地方使用共享对象就会造成不安全**如果一定要用**，除了加锁，没法解决；

可以不用吗？--不要设置太多的共享属性|共享属性是不可变的

可以少用|避免吗？--根因是因为多个地方使用一个东西，让每个人用自己的就不会出问题了---ThreadLocal

## Executor

Executor提交不需要返回值的任务

run方法是执行的真正方法，需要修改run，就可以实现子线程和父线程的数据传递

Executor比Thread.start更好，包含：创建runnable，执行，处理结果

## CompletableFuture

cf.isCompletedExceptionally()这个方法并不好用，因为这个需要等到异步任务执行完之后调用才有效，
但是等待雨布执行完，需要try{cf.join} catch ，或者while(cf.isDone)

2种方式均不友好：不要让cf抛异常，应该将异常结果收集起来，然后join判断

    // 这块代码是没有阻塞效果的，创建的任务是异步任务，整个join都是异步执行的
    CompletableFuture<Void> res=CompletableFuture.runAsync(()->calRes(list.join))

## CAS

首先将内存位置的值和预期值比较，如果相匹配，处理器会自动将该内存位置的值更新为新值，并返回true；如果不匹配，处理器不进行任何操作，并返回false

see java unsafe.java

// 字段对象，字段内存位置，预期原值，新值
compare and swap(object o,long offset,long expected,long x)

cas的问题：

    因为是比较，如果存在由a改为b再改为a就会出现判断错误，可以用jdk其他工具帮助：AtomicStampedReference
    只能保证一个变量的原子操作，可以把i j放入一个对象中，对对象cas

自旋锁问题：

    首先声明，cas仅仅是一次判断，不包含自旋锁；但是我们使用cas的时候，大概率会循环调用，
    如果为期望结果的时候，才放行，自己循环自己，形成自旋锁
        
    高并发情况下，会造成大量cas失败（因为同一时间仅仅只能成功一个），会浪费CPU性能，降低并发：
    1.使用LongAddr
    2.削峰 列如AQS

