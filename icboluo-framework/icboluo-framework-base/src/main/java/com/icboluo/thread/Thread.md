## sleep

Thread.sleep(0) 的作用：告诉cpu，我吃饱了，暂时不参与竞争\
在一个大的循环体中，放一个这个可以释放cpu资源，让其他的线程再进行竞争（界面不会出现卡死

# 锁

## 公平锁

多个线程按照申请顺序来获取锁

## 非公平锁

随便加进去

## 可重入锁

调用子函数不会死锁

## 多线程

每一个请求都会使用一个线程，tomcat会维护一个线程池，每个http请求会在tomcat中取一个空闲的线程

多线程中有任务调度的时间，单核cpu的效率是下降的，内核级别的多线程（多核cpu）效率会提升

## async

async必须交给spring，不能自己new

自己类调用自己是没有效果的

then apply 前后是同一个线程执行（。。。

async同类调用没有效果：用的是aop，aop用的是动态代理；动态代理针对的是方法级别，方法内部调用本类的方法，是不会使用到代理类的

## mdc

mdc使用的是 thread local，可以当做thread local使用，异步线程之间通信可以使用mdc和thread local，mdc支持日志的追踪定位等功能

## thread local

thread local相当于一个线程的一个全局变量

thread local不是解决对象共享访问问题的，主要是提供了保持对象的方法和 避免参数传递 的方便的对象访问方式

thread local和@async 前面的代表本地线程，后面代表异步线程，数据不能共享，可以用线程池、代理增强等方式处理

## sleep wait

sleep和wait均针对于锁，他们的不同和线程无关，均不会释放线程

## volition

防止指令重排

## 效率

异步追求效率的过程中，cf比join要好很多，cf能更小颗粒度的控制流程

## 异常排查

多线程内部问题调查，debug没有打印日志好用，相当于乱序debug，细节难以把握，应该泛泛的从日志分析，这样更加简单

记录死锁：

        多线程delete的时候死锁，原因是因为，多个线程同时del同一组数据
        调查吃力原因：只能从mysql中读取到那个表锁住了，不知道有多个操作同时操作这个表

        单个方法异常，其他线程回滚，但是本地线程也需要回滚，否则，事物会一直挂起，导致第二次以后的调用均会失败
        
        多线程操作同一张表，虽然一个删除是空删除，没有删除到同一行数据：查看死锁日志需要关注锁表
        具体场景如下：del a where b=; del a where c=; 其中任意一个有数据即可死锁；2个都没有不会死锁
        mysql一个navicat页面就是一次链接，也是一次会话，idea窗口同理，多次会话直接可以做事物测试


## 线程池

线程池中的最大线程数触发时机：当核心线程满了之后，然后队列也满了，线程数量就会由核心线程数量变为最大线程数量

对于cf而言，队列容量为max，所以永远不会触发最大线程数量，除非同时也修改了队列容量

## 单例对象的多线程不安全

单例对象--共享对象；多线程---多个地方使用：多个地方使用共享对象就会造成不安全**如果一定要用**，除了加锁，没法解决；

可以不用吗？--不要设置太多的共享属性|共享属性是不可变的

可以少用|避免吗？--根因是因为多个地方使用一个东西，让每个人用自己的就不会出问题了---ThreadLocal

## Executor

Executor提交不需要返回值的任务

run方法是执行的真正方法，需要修改run，就可以实现子线程和父线程的数据传递

Executor比Thread.start更好，包含：创建runnable，执行，处理结果
