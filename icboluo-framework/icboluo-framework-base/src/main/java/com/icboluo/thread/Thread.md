## 最常用的在上面，并不是最基础的在上面

## sleep

Thread.sleep(0) 的作用：告诉cpu，我吃饱了，暂时不参与竞争\
在一个大的循环体中，放一个这个可以释放cpu资源，让其他的线程再进行竞争（界面不会出现卡死

# 锁

## 公平锁

多个线程按照申请顺序来获取锁

## 非公平锁

随便加进去

## 可重入锁

调用子函数不会死锁

## 多线程

每一个请求都会使用一个线程，tomcat会维护一个线程池，每个http请求会在tomcat中取一个空闲的线程

多线程中有任务调度的时间，单核cpu的效率是下降的，内核级别的多线程（多核cpu）效率会提升

## async

async必须交给spring，不能自己new

自己类调用自己是没有效果的

then apply 前后是同一个线程执行（。。。

async同类调用没有效果：用的是aop，aop用的是动态代理；动态代理针对的是方法级别，方法内部调用本类的方法，是不会使用到代理类的

## mdc

mdc使用的是 thread local，可以当做thread local使用，异步线程之间通信可以使用mdc和thread local，mdc支持日志的追踪定位等功能

## thread local

thread local相当于一个线程的一个全局变量

thread local不是解决对象共享访问问题的，主要是提供了保持对象的方法和 避免参数传递 的方便的对象访问方式

thread local和@async 前面的代表本地线程，后面代表异步线程，数据不能共享，可以用线程池、代理增强等方式处理

## sleep wait

sleep和wait均针对于锁，他们的不同和线程无关，均不会释放线程

## volition

防止指令重排

## 效率

异步追求效率的过程中，cf比join要好很多，cf能更小颗粒度的控制流程

## 异常排查

多线程内部问题调查，debug没有打印日志好用，相当于乱序debug，细节难以把握，应该泛泛的从日志分析，这样更加简单

记录死锁：

        多线程delete的时候死锁，原因是因为，多个线程同时del同一组数据
        调查吃力原因：只能从mysql中读取到那个表锁住了，不知道有多个操作同时操作这个表

        单个方法异常，其他线程回滚，但是本地线程也需要回滚，否则，事物会一直挂起，导致第二次以后的调用均会失败
        
        多线程操作同一张表，虽然一个删除是空删除，没有删除到同一行数据：查看死锁日志需要关注锁表
        具体场景如下：del a where b=; del a where c=; 其中任意一个有数据即可死锁；2个都没有不会死锁
        mysql一个navicat页面就是一次链接，也是一次会话，idea窗口同理，多次会话直接可以做事物测试

        可以搭配 explain 查看锁表情况，执行计划估算要读取的行数，读取的行数是1说明是行锁，读取的行数是多，说明是表锁，
        同样是删除操作，尽量让删除条件统一，这样不会锁表
        
        insert是表锁，因为要生成主键字段，索引等等，update是行级锁
        mysql的InnoDB存储支持行级锁，InnoDB的行锁是通过给索引项加锁实现的。这就意味着只有通过索引条件检索数据时，InnoDB才使用行锁，否则使用表锁
        InnoDB的行销是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁
## 线程池

线程池中的最大线程数触发时机：当核心线程满了之后，然后队列也满了，线程数量就会由核心线程数量变为最大线程数量

对于cf而言，队列容量为max，所以永远不会触发最大线程数量，除非同时也修改了队列容量

## 单例对象的多线程不安全

单例对象--共享对象；多线程---多个地方使用：多个地方使用共享对象就会造成不安全**如果一定要用**，除了加锁，没法解决；

可以不用吗？--不要设置太多的共享属性|共享属性是不可变的

可以少用|避免吗？--根因是因为多个地方使用一个东西，让每个人用自己的就不会出问题了---ThreadLocal

## Executor

Executor提交不需要返回值的任务

run方法是执行的真正方法，需要修改run，就可以实现子线程和父线程的数据传递

Executor比Thread.start更好，包含：创建runnable，执行，处理结果

## CompletableFuture

cf.isCompletedExceptionally()这个方法并不好用，因为这个需要等到异步任务执行完之后调用才有效，
但是等待异步执行完，需要try{cf.join} catch ，或者while(cf.isDone)

2种方式均不友好：不要让cf抛异常，应该将异常结果收集起来，然后join判断

    // 这块代码是没有阻塞效果的，创建的任务是异步任务，整个join都是异步执行的
    CompletableFuture<Void> res=CompletableFuture.runAsync(()->calRes(list.join))

## CAS

首先将内存位置的值和预期值比较，如果相匹配，处理器会自动将该内存位置的值更新为新值，并返回true；如果不匹配，处理器不进行任何操作，并返回false

see java unsafe.java

// 字段对象，字段内存位置，预期原值，新值
compare and swap(object o,long offset,long expected,long x)

cas的问题：

    因为是比较，如果存在由a改为b再改为a就会出现判断错误，可以用jdk其他工具帮助：AtomicStampedReference
    只能保证一个变量的原子操作，可以把i j放入一个对象中，对对象cas

自旋锁问题：

    首先声明，cas仅仅是一次判断，不包含自旋锁；但是我们使用cas的时候，大概率会循环调用，
    如果为期望结果的时候，才放行，自己循环自己，形成自旋锁
        
    高并发情况下，会造成大量cas失败（因为同一时间仅仅只能成功一个），会浪费CPU性能，降低并发：
    1.使用LongAddr
    2.削峰 列如AQS

## 进程和线程

#### 进程

进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的

系统运行一个程序即是一个进程从创建、运行到消亡的过程

java中，启动main函数就是启动了一个JVM进程，而main函数所在的线程就是这个进程中的一个线程，也称主线程

#### 线程

线程是比进程更小的执行单元，一个进程在执行过程中可以产生多个线程

同类的多个线程共享进程的堆和方法区的资源

每个线程有自己的**程序计数器、虚拟机栈和本地方法栈**

系统在产生一个线程，或是在各个线程之间作切换，负担要比进程小很多，所以，线程也是轻量级进程

#### 关系

多个线程共享进程的堆和方法区（元空间 资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈

基本上各进程是独立的，而各线程则不一定，同一进程中的线程极有可能会相互影响

线程执行开销小，但不利于资源的管理和保护，而进程正相反

#### 程序计数器

* 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理
* 多线程情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行位置

> 如果执行的是native方法，那么程序计数器记录的是undefined地址；只有执行的是java代码时程序计数器记录的才是下一条指令的地址

程序计数器私有的主要目的是为了线程切换后能恢复到正确的执行位置

#### 虚拟机栈和本地方法栈

虚拟机栈：每个java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息\
从方法调用直至执行完成的过程，就对应着一个栈帧在java虚拟机栈中入栈和出栈的过程

本地方法栈：虚拟机栈为虚拟机执行java方法（也就是字节码 服务，而本地方法栈则为虚拟机使用到native方法服务\
在HotSpot虚拟机中和java虚拟机栈合二为一

私有保证线程中局部变量不被别的线程访问到

堆和方法区是所有线程共享的资源，其中堆比较大（主要存放新建的对象（几乎所有的对象都在这里分配内存\
方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

## 并发与并行

并发：多个以上的作业在同一**时间段**内执行

## 多线程

多线程可以提高系统的并发能力以及性能

相对于进程：线程更加轻量，是程序执行的最小单位；线程间的切换和调度的成本远远小于进程\
多核cpu意味着多个线程可以同时运行，减少了线程上下文切换的开销

单核情况下：使用多线程主要是为了提高单进程利用cpu和IO系统的效率

    假设只运行一个java进程，一个线程，请求IO的时候，此线程被IO阻塞，则整个进程被阻塞。cpu和IO设备永远只有一个
    在运行；这时，简单认为系统的效率为50%；当使用多线程的时候，一个线程被IO阻塞，其他线程还可以使用cpu...,可以
    提高了java进程利用系统资源的整体效率

多核情况下：多线程主要是为了提高进程利用多核cpu的能力；一个进程一个线程的情况下，无论系统有几个cpu核心，
都只会有一个cpu核心被利用到；创建多线程，这些线程可以被映射到底层多个cpu上执行，在任务中多个线程没有资
源竞争的情况下，任务执行的效率会有显著的提高，=单核时间数/cpu核心数

并发线程并不总是能提高程序运行速度，而且并发线程会遇到：内存泄漏、死锁、线程不安全...

## 线程状态

1.new 新建，线程被创建，但是还没有调用start方法\
2.runnable 运行（java没有就绪状态，把就绪和运行一起称为运行\
3.blocked 阻塞，表示线程阻塞于锁\
4.waiting 等待，进入该状态表示当前线程需要等待其他线程做出一些 通知|中断 动作\
5.timed_waiting 有时间的等待，可以自己通知自己，指定时间自行返回\
6.terminated 终止，表示当前线程一级执行完毕

```java
public class MyThread {
    /**
     * <p> Thread.State 以下内容摘自State
     * <p> These states are virtual machine states which do not reflect
     * any operating system thread states.
     * <p> 这些状态是 不反映任何操作系统线程状态 的虚拟机状态。
     * <p>
     * <p> Thread.State.RUNNABLE 以下内容摘自RUNNABLE
     * <p> A thread in the runnable
     * state is executing in the Java virtual machine but it may
     * be waiting for other resources from the operating system
     * such as processor.
     * <p> 处于可运行状态的线程正在 Java 虚拟机中执行，但它可能正在等待来自操作系统的其他资源，例如处理器。
     * <p>
     * @see Thread.State
     */
    private void state() {

    }
}
```

在操作系统层面有ready和running状态，而在JVM层面只能看到runnable状态

调用start方法后开始运行，线程这时候处理ready状态；可运行状态的线程获得了cpu时间片（timeslice 后就处于running状态

线程的状态切换如下图所示：（图源：《Java并发编程艺术》 4.1.4节

![Java线程状态切换](thread2/thread)

在操作系统层面线程有ready和runnable状态；在JVM层面只能看到runnable状态
> （摘自：[java线程运行怎么有第六种状态？ - Dawell的回答](https://www.zhihu.com/question/56494969/answer/154053599) ）
> 现在的<b>时分</b>（time-sharing）<b>多任务</b>（multi-task）操作系统架构通常都是用所谓的“<b>时间分片</b>（time quantum or time slice）”方式进行<b>抢占式</b>（preemptive）
> 轮转调度（round-robin式）。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用
> 后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。
>
> 参考上面的注释（均摘自源码; runnable包含ready和running状态；主流JVM会把java的线程映射到操作系统底层的线程上，把调度委托给了操作系统，
> 我们能在虚拟机层面看到的状态是对底层状态的映射和封装。JVM本身没有做实质上的调度，因为底层ready和running状态切换较快，而java线程状态
> 是服务于监控的，区分2种意义不大（存疑），因此JVM做成了一种
>
> 时间分片一次在cpu上运行的时间为15ms左右（不准确），也就是说running状态一共执行15ms就切换到ready状态了（也有可能15ms就结束了，变成其他状态了

## 上下文切换

线程再执行过程中会有自己的运行条件和状态（也称上下文），比如程序计数器、栈信息等\
当出现如下情况的时候，线程会从占用cpu状态退出\
* 主动让出cpu；例如sleep，wait
* 时间分片用完；操作系统要防止一个线程或进程长时间占用cpy导致其他线程饿死
* 调用阻塞类型的系统中断；比如请求IO，线程被阻塞
* 被终止或结束运行
