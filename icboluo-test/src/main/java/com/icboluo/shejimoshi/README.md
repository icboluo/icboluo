# 设计模式

uml类图：...这个就是类接口继承实现图...

使用设计模式，可以让代码有以下优点

代码重用性：相同的代码，不用多次编写

可读性：编程规范性，便于理解

可扩展性：增加新的功能的时候非常的方便

可靠性：新增功能，对原有功能没有影响

对外呈现一种高内聚，低耦合

## 设计模式中七大设计原则

### 1.单一职责

对于一个类来说，这个类应该只负责一项职责，for example：user不要负责user+order 2项职责

### 2.接口隔离

客户端不应该依赖他不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上(可以把接口拆成最小的，不用的不要)

### 3.依赖倒置/依赖倒转 dependence inversion principle

高层模块不要依赖底层模块，二者都应该依赖其抽象

依赖倒转的设计理念：已抽象为基础搭建起来的架构比已细节为基础搭建的架构稳定的多

抽象不应该依赖细节，细节应该依赖抽象

依赖倒转的中心思想：面向接口编程

依赖传递的3种方式：

接口传递、构造方法传递、set方法传递

### 4.里式替换原则

子类中尽量不要重写父类的方法（如果你基础父类，又把它的所有方法都给重写了，那你为什么还要继承）

将原有的父类和子类共同继承一个基类，取消原有的继承关系

### 5.开闭原则

一个模块应该对扩展开放（对提供功能方），对修改关闭（对使用方）

用抽象构建框架，用实现扩展细节

软件需要变换，尽量通过扩展软件实体，而不是通过修改已有代码

### 6.迪米特法则/最少知道原则

一个对象应该对其他对象保持最少的了解

只与直接朋友通信，陌生的类最好不要以局部变量的形式出现在类的内部

teacher类不要生成一个student的list，让student自己去生成，不要把具体实现的方法让外部知道

### 7.合成复用原则

## uml图

### 类图 

描述类与类之间关系

依赖：a用到b，a依赖于b

# 设计模式

## 创建型模式

强调的是对象的创建

## 结构型模式

## 行为型模式

## 单例模式

采取一定的方法，保证在系统中某个类只存在一个对象实例

并且该类提供一个取得其对象实例的方法（静态方法）

单例模式的使用场景：

需要频繁的创建和销毁对象、创建对象时消耗时间或资源过多，单又经常使用

、工具类、

## 工厂模式

### 简单工厂模式

### 工厂方法模式

### 抽象工厂模式

## 原型模式

### 深拷贝

clone 接口实现

序列化实现

用序列化，将对象转化成输入流，在反序列化成输出流转换成新的对象

## 建造者模式

建造房屋

## 适配器模式

转换电压

## 桥接模式

手机 2/2组合问题

## 装饰者模式

咖啡，套娃，内部用递归处理

## 组合模式

大学->院系->专业

上层有多个下层->每个下层还有多个下层...

能够把这种关系组合起来

## 外观模式

影院开始/暂停/结束

下层有 灯光/爆米花机/屏幕/电影...

主要的功能是把下层进行封装，方便上层调用

## 享元模式

网站外包

分内部内容和外部内容

## 代理模式

代理模式是对原方法进行增强，有点像aop

### 静态代理

### 动态代理

### cglib代理

被代理对象不需要实现一个接口了

### 代理模式的变体

防火墙代理

缓存代理

远程代理

同步代理

## 模板模式

定义统一模板，只改其中一部分

模板钩子方法，确定需不需要这个模板方法等...

## 命令模式

遥控器

但是增加一个tv相当于增加3个类...

## 访问者模式

## 迭代器模式

## 观察者模式

## 中介者模式

## 备忘录模式

## 解释器模式

## 状态模式

## 策略模式

## 职责链模式






