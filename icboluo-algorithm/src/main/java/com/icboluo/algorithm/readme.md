## 建模题：多叉树构建

对于构造函数，我们需要多增加一些映射、数组等关系构建，方便后面的查询处理；

一般意义上，不要太在乎复杂度，for循环慢慢写，不会出问题

## 拓扑排序

求字符串的满足某种规则的切割方式：1.先求出所有满足规则的子串；2.对子串进行从前到后的索引拼接，查看是否拼接后的结果为完整字符串（可以采取拓扑排序的方式处理

## 常量值

算法不要使用静态变量存储值，因为静态变量是全局变量，可能有数据串起来的问题

算法中存储多次访问的值用数组比较合适，单次访问的使用使用常量

## 完全二叉树

完全二叉树的高度；好多算法中时间复杂度其实是log2 n，用log n来表示是不准确的，有一定的误导作用

## 优先级队列

PriorityQueue 没有在offer上实现排序，仅仅是poll的时候实现了排序，所以toString看起来有bug，不可以这样看

## 图

图的存储方式：邻接矩阵（二维数组），邻接表（Linkedlist[]） 常用的是邻接表，这个api比较多一点

针对贪吃蛇在图的四周移动，求移动结果的时候，我们可以将图的四周再做成图；因为图的四周难以判断，这里的思路有2种：

    1.每一个顶点作为新图的顶点
    2.每一条横边做成一个图，竖边做成一个图

似乎每一个顶点做成图更简单一点


## 基本

基本操作：增删改

遍历方式：递归迭代

算法是用合适的数据结构解决特定问题

low代表低优先级，题意难以理解，或者特别偏，不是很重要，重复等情况

## 测试

做psvm的测试用例也是有必要的，即便方法通过了，再次debug比较方便

## jdk

Set源码注释：集合元素的迭代顺序未指定，可能会更改
