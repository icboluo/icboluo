## 建模题：多叉树构建

对于构造函数，我们需要多增加一些映射、数组等关系构建，方便后面的查询处理；

一般意义上，不要太在乎复杂度，for循环慢慢写，不会出问题

## 拓扑排序

求字符串的满足某种规则的切割方式：1.先求出所有满足规则的子串；2.对子串进行从前到后的索引拼接，查看是否拼接后的结果为完整字符串（可以采取拓扑排序的方式处理

## 常量值

算法不要使用静态变量存储值，因为静态变量是全局变量，可能有数据串起来的问题

算法中存储多次访问的值用数组比较合适，单次访问的使用使用常量

## 完全二叉树

完全二叉树的高度；好多算法中时间复杂度其实是log2 n，用log n来表示是不准确的，有一定的误导作用

## 优先级队列

PriorityQueue 没有在offer上实现排序，仅仅是poll的时候实现了排序，所以toString看起来有bug，不可以这样看

## 图

图的存储方式：邻接矩阵（二维数组），邻接表（Linkedlist[]） 常用的是邻接表，这个api比较多一点

针对贪吃蛇在图的四周移动，求移动结果的时候，我们可以将图的四周再做成图；因为图的四周难以判断，这里的思路有2种：

    1.每一个顶点作为新图的顶点
    2.每一条横边做成一个图，竖边做成一个图

似乎每一个顶点做成图更简单一点


## 基本

基本操作：增删改

遍历方式：递归迭代

算法是用合适的数据结构解决特定问题

low代表低优先级，题意难以理解，或者特别偏，不是很重要，重复等情况

## 测试

做psvm的测试用例也是有必要的，即便方法通过了，再次debug比较方便

## jdk

Set源码注释：集合元素的迭代顺序未指定，可能会更改

SortSet 就是有序的Set，对Set接口进行了增强，他是基于比较器实现的，并不是添加的先后顺序，TreeSet就是基于此实现的

jdk 并没有针对于添加的先后顺序进行接口的设计，然后有一些实现类却实现了这个功能，例如 LinkedListHashMap LinkedListHashSet LinkedList

jdk 中没有单纯的 随机访问数组 和 顺序访问链表;

List 接口本身就是 数组+链表的合体，他的所有子类均可以作为链表和数组的数据结构，不过在时间复杂度上有些偏差而已

ArrayList 是基于数组实现的，所以他的next就是简单的i++，但是中间的 新增、删除 需要整体数组copy

LinkedList 是基于链表实现的，所以他的get()需要线性遍历

AbstractSequentialList 抽象顺序列表 实现由 顺序访问 数据存储（如链表）支持的此接口锁需的工作量

对于随机访问数据（如数组），应优先使用抽象列表，而不是此类

## 复杂算法

题目1. 求a-b的必须经过点（交集）, 需要计算a-b的一条经过点，将这些点逐一设置成不可访问，再次求a-b的路径，如果不能到达，则证明该点必须
