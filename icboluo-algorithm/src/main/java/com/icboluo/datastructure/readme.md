## 红黑树

#### 特性

> 1.每个节点要么是红色，要么是黑色
> 2.根节点是黑色
> 3.每个叶子节点是黑色（注意：这里的叶子节点，是指为空的叶子节点，也就是实际上叶子节点的子节点）
> 4.如果一个节点是红色的，则它的子节点必须是黑色的
> 5.从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点

#### 插入

    1.将插入的节点弄成红色-》父节点黑色，不做处理
    父节点红色
    
    父节点是左节点-》叔叔是红色
                    -》叔叔是黑色
                        -》当前节点是左节点
                        -》当前节点是右节点
    父节点是右节点-》叔叔是红色
                -》叔叔是黑色
                    -》当前节点是左节点
                    -》当前节点是右节点

## 顺序存储二叉树

顺序存储二叉树 针对的是完全二叉树，其实是二叉树的层级遍历；是根据2*n的公式来的

## 线索化二叉树

线索化二叉树是利用到未使用的指针信息，使二叉树操作更方便(前驱节点，后继节点)

## 为什么使用B+树不适用B树

    1.B+树数据均存储在叶子节点上

## 图

#### 新建图

根据是否有向图构建，下面的是有向图，仅需要构建单边

        LinkedList<int[]>[] graph = new LinkedList[num];
        for (int i = 0; i < num; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge : arr) {
            // 这里是由1可以到0
            graph[edge[1]].add(edge[0]);
        }

#### 图遍历

        private void list(LinkedList<Integer>[] graph, int start) {
        // 拓扑排序需要这个判断
        if (isPath[start]) {
            hasCycle = true;
            return;
        }
        if (visited[start]) {
            return;
        }
        visited[start] = true; // 防止b-a-b这种循环遍历
        isPath[start] = true; // 前序遍历，遍历之前设置一个值，如果遍历的时候再访问到这个节点，说明有环
        for (Integer child : graph[start]) {
            list(graph, child);
        }
        isPath[start] = false; // 回溯
    }


## 排序

快速排序相当于：将数组用第一个元素作为基准元素，将小于基准的元素放到左边，将大于基准的元素放到右边
整体操作步骤如下，因取左1为基准元素，所以左1可以当做临时变量存储，其位置可以被右边较小的元素占用
循环取右边直到右边元素小于基准元素，放入左1;
