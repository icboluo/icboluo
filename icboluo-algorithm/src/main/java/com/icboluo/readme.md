leetcode 中的类名命名以github上的资源LeetCodeAnimation开始，因为不能以数字开始命名，所以用_做开始标记

文件名后半部分是功能描述

# 数组存储：

插入值的时候会造成整体移动，效率较低

以ArrayList 为例，构造方法是一个空数组，用grow方法扩容

# 链式存储

检索效率较低

# 树结构

查询、增加效率都比较高

树的一些 描述
```
节点、根节点、父节点、子节点、叶子节点、节点的权（val）
路径（根->该节点）、层、子树、树的高度、森林
```

二叉树：每个节点最多只有2个子节点

满二叉树：叶子节点都在最后一层、最后一层是满的（2.n-1）

完全二叉树：最后一层叶子节点左边连续，倒数第二层右边连续

## 树的前序遍历、前序查找

```
print cur
if left!=null, left.pre
if right!=null, right.pre

if ==  return
if left!=null left.pre
if right!=null right.pre
```

## 二叉树的删除

二叉树是由上到下单向的，所以删除的时候只能根据

cur 判断 left or right 是否需要删除

删除分叶子节点和非叶子节点，分开考虑（可以假定一种

删除方式，删除非叶子节点的时候，直接删除子树

## 顺序存储二叉树（只能存储完全二叉树吗？）

把二叉树存储到数组当中

第n个元素的左子节点为 2n+1
第n个元素的右子节点为 2n+2
第n个元素的父节点为 (n-1)/2

## 线索化二叉树

对空指针指向前驱/后继节点，增加空指针的使用率

因为left可能指向左子树或者前驱节点，所以要再进行区分

## avl树 平衡二叉树 

解决某些情况下二叉树退化成链表的问题

## 赫夫曼树

解决定长编码的问题，用于压缩和解压

# 图

线性表：一个前驱，一个后继

树：一个前驱，多个后继

图：多个前驱，多个后继

## 图的相关描述

```
顶点 vertex
边 edge
路径 a->b/b->a
无向图
有向图
带权图
```

## 表示图

### 邻接矩阵 

是一个二维数组，不存在顶点的边也画，描述的是顶点与顶点之间的关系

### 邻接表

链表+数组 只关系存在的边，不关心不存在的边，以结点
为数组的起始表示和哪一个相连
0->7->8 表示0和7相连，0和8相连

## 创建图

图里面应该含有 vertex edge numOfEdge（边的个数）

深度优先遍历 dfs

先访问当前邻接节点的第一个邻接节点



